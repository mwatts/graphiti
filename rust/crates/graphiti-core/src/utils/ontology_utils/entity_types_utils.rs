/*
Copyright 2024, Zep Software, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//! Entity type validation utilities

use crate::errors::GraphitiError;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// Entity type definition for validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntityType {
    pub name: String,
    pub fields: HashMap<String, String>, // field_name -> field_type
}

/// Validate entity types against EntityNode fields
pub fn validate_entity_types(
    entity_types: Option<&HashMap<String, EntityType>>,
) -> Result<bool, GraphitiError> {
    let Some(entity_types) = entity_types else {
        return Ok(true);
    };

    // Get EntityNode field names (this would be derived from the struct definition)
    let entity_node_fields = get_entity_node_field_names();

    for (entity_type_name, entity_type) in entity_types {
        for field_name in entity_type.fields.keys() {
            if entity_node_fields.contains(field_name) {
                return Err(GraphitiError::EntityTypeValidation {
                    entity_type: entity_type_name.clone(),
                    field_name: field_name.clone(),
                });
            }
        }
    }

    Ok(true)
}

/// Get the field names of EntityNode struct
/// In a real implementation, this could use reflection or be generated by a macro
fn get_entity_node_field_names() -> HashSet<String> {
    vec![
        "uuid".to_string(),
        "name".to_string(),
        "summary".to_string(),
        "labels".to_string(),
        "attributes".to_string(),
        "created_at".to_string(),
        "valid_at".to_string(),
        "group_id".to_string(),
        "name_embedding".to_string(),
    ]
    .into_iter()
    .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_entity_types_none() {
        assert!(validate_entity_types(None).is_ok());
    }

    #[test]
    fn test_validate_entity_types_valid() {
        let mut entity_types = HashMap::new();
        let mut entity_type = EntityType {
            name: "Person".to_string(),
            fields: HashMap::new(),
        };
        entity_type
            .fields
            .insert("age".to_string(), "u32".to_string());
        entity_type
            .fields
            .insert("occupation".to_string(), "String".to_string());

        entity_types.insert("Person".to_string(), entity_type);

        assert!(validate_entity_types(Some(&entity_types)).is_ok());
    }

    #[test]
    fn test_validate_entity_types_invalid() {
        let mut entity_types = HashMap::new();
        let mut entity_type = EntityType {
            name: "Person".to_string(),
            fields: HashMap::new(),
        };
        // This should conflict with EntityNode's uuid field
        entity_type
            .fields
            .insert("uuid".to_string(), "String".to_string());

        entity_types.insert("Person".to_string(), entity_type);

        let result = validate_entity_types(Some(&entity_types));
        assert!(result.is_err());

        if let Err(GraphitiError::EntityTypeValidation {
            entity_type,
            field_name,
        }) = result
        {
            assert_eq!(entity_type, "Person");
            assert_eq!(field_name, "uuid");
        } else {
            panic!("Expected EntityTypeValidation error");
        }
    }
}
